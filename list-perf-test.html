<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>List Performance Test - Placeholder vs Virtual</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }

    .controls {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .controls > * {
      margin-right: 10px;
      margin-bottom: 10px;
    }

    select, input, button {
      padding: 8px 12px;
      font-size: 14px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    button {
      background: #007bff;
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 500;
    }

    button:hover {
      background: #0056b3;
    }

    .stats {
      display: inline-block;
      margin-left: 20px;
      font-size: 14px;
      color: #666;
    }

    .list-container {
      height: 600px;
      overflow-y: auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
    }

    .list-content {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      padding: 16px;
    }

    .list-content.virtual {
      position: relative;
      padding: 0;
    }

    .item {
      width: 200px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .item img {
      display: block;
      width: 200px;
      height: 150px;
      object-fit: cover;
      background: #f0f0f0;
    }

    .item .name {
      padding: 8px 12px;
      font-weight: 600;
      font-size: 14px;
    }

    .item .desc {
      padding: 0 12px 12px 12px;
      font-size: 12px;
      color: #666;
    }

    .placeholder {
      width: 200px;
      height: 244px; /* img(150) + name(~30) + desc(~30) + padding */
      background: #f0f0f0;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      content-visibility: auto;
      contain-intrinsic-size: 200px 244px;
    }

    .virtual-item {
      position: absolute;
      left: 0;
    }

    .content-visibility-item {
      content-visibility: auto;
      contain-intrinsic-size: 200px 244px;
    }
  </style>
</head>
<body>
  <div class="controls">
    <label>
      Approach:
      <select id="approach">
        <option value="placeholder">Placeholder</option>
        <option value="virtual">Virtual</option>
        <option value="none">No Optimization</option>
        <option value="content-visibility">Content Visibility</option>
      </select>
    </label>

    <label>
      Item Count:
      <input type="number" id="itemCount" value="1000" min="100" step="100">
    </label>

    <button id="renderBtn">Render List</button>

    <span class="stats">
      <span id="renderTime">Render time: -</span>
      <span style="margin-left: 20px;" id="fps">FPS: -</span>
    </span>
  </div>

  <div class="list-container" id="listContainer">
    <div class="list-content" id="listContent"></div>
  </div>

  <script>
    // Element pool for reusing DOM nodes
    class ElementPool {
      constructor(template) {
        this.template = template;
        this.available = [];
      }

      acquire() {
        if (this.available.length > 0) {
          return this.available.pop();
        }
        const temp = document.createElement('div');
        temp.innerHTML = this.template;
        return temp.firstElementChild;
      }

      release(element) {
        this.available.push(element);
      }

      clear() {
        this.available = [];
      }
    }

    // Generate test data
    function generateItems(count) {
      const items = [];
      for (let i = 0; i < count; i++) {
        items.push({
          id: i,
          name: `Item ${i}`,
          description: `Description for item ${i}`,
          imageUrl: `https://picsum.photos/seed/${i}/200/150`
        });
      }
      return items;
    }

    // Configure an element with item data
    function configure(item, element) {
      element.querySelector('.name').textContent = item.name;
      element.querySelector('.desc').textContent = item.description;
      element.querySelector('img').src = item.imageUrl;
    }

    // Item template
    const itemTemplate = `<div class="item">
      <img src="" width="200" height="150"/>
      <div class="name"></div>
      <div class="desc"></div>
    </div>`;

    const placeholderTemplate = `<div class="placeholder"></div>`;

    // Global state
    let currentApproach = null;
    let items = [];
    let pool = null;
    let observers = [];

    // FPS tracking
    let lastTime = performance.now();
    let frames = 0;
    let fps = 0;

    function updateFPS() {
      frames++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = Math.round(frames * 1000 / (now - lastTime));
        document.getElementById('fps').textContent = `FPS: ${fps}`;
        frames = 0;
        lastTime = now;
      }
      requestAnimationFrame(updateFPS);
    }
    requestAnimationFrame(updateFPS);

    // ===== PLACEHOLDER APPROACH =====
    class PlaceholderList {
      constructor(container, items) {
        this.container = container;
        this.items = items;
        this.pool = new ElementPool(itemTemplate);
        this.placeholderPool = new ElementPool(placeholderTemplate);
        this.placeholderToItem = new Map();
        this.itemToElement = new Map();
        this.observer = null;
      }

      render() {
        this.container.className = 'list-content';
        this.container.innerHTML = '';

        // Create all placeholders from pool
        const fragment = document.createDocumentFragment();
        this.items.forEach((item, index) => {
          const placeholder = this.placeholderPool.acquire();
          placeholder.dataset.index = index;
          this.placeholderToItem.set(placeholder, item);
          fragment.appendChild(placeholder);
        });
        this.container.appendChild(fragment);

        // Set up intersection observer
        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const placeholder = entry.target;
            const item = this.placeholderToItem.get(placeholder);

            if (!item) return;

            if (entry.isIntersecting) {
              // Swap placeholder -> full element
              if (!this.itemToElement.has(item)) {
                const element = this.pool.acquire();
                configure(item, element);
                placeholder.replaceWith(element);
                this.placeholderToItem.delete(placeholder);
                this.placeholderToItem.set(element, item);
                this.itemToElement.set(item, element);
                this.placeholderPool.release(placeholder);
              }
            } else {
              // Swap full element -> placeholder
              const element = this.itemToElement.get(item);
              if (element) {
                const newPlaceholder = this.placeholderPool.acquire();
                newPlaceholder.dataset.index = placeholder.dataset.index;

                element.replaceWith(newPlaceholder);
                this.placeholderToItem.delete(element);
                this.placeholderToItem.set(newPlaceholder, item);
                this.itemToElement.delete(item);
                this.pool.release(element);
              }
            }
          });
        }, {
          root: this.container.parentElement,
          rootMargin: '200px'
        });

        // Observe all placeholders
        this.container.querySelectorAll('.placeholder').forEach(p => {
          this.observer.observe(p);
        });
      }

      destroy() {
        if (this.observer) {
          this.observer.disconnect();
        }
        this.pool.clear();
        this.placeholderPool.clear();
        this.placeholderToItem.clear();
        this.itemToElement.clear();
      }
    }

    // ===== VIRTUAL SCROLLING APPROACH =====
    class VirtualList {
      constructor(container, items) {
        this.container = container;
        this.scrollContainer = container.parentElement;
        this.items = items;
        this.pool = new ElementPool(itemTemplate);

        this.itemHeight = 244; // height + gap
        this.itemWidth = 216; // width + gap
        this.visibleCount = 50;
        this.renderedItems = new Map();

        this.onScroll = this.onScroll.bind(this);
      }

      render() {
        this.container.className = 'list-content virtual';
        this.container.innerHTML = '';

        // Calculate grid dimensions
        const containerWidth = this.scrollContainer.clientWidth;
        this.itemsPerRow = Math.floor(containerWidth / this.itemWidth);
        const totalRows = Math.ceil(this.items.length / this.itemsPerRow);

        // Set total height
        this.container.style.height = `${totalRows * this.itemHeight}px`;

        // Initial render
        this.onScroll();

        // Listen to scroll
        this.scrollContainer.addEventListener('scroll', this.onScroll);
      }

      onScroll() {
        const scrollTop = this.scrollContainer.scrollTop;
        const containerHeight = this.scrollContainer.clientHeight;

        // Calculate visible range with buffer
        const startRow = Math.max(0, Math.floor(scrollTop / this.itemHeight) - 2);
        const endRow = Math.min(
          Math.ceil(this.items.length / this.itemsPerRow),
          Math.ceil((scrollTop + containerHeight) / this.itemHeight) + 2
        );

        const startIndex = startRow * this.itemsPerRow;
        const endIndex = Math.min(this.items.length, endRow * this.itemsPerRow);

        // Remove items outside visible range
        for (const [index, element] of this.renderedItems.entries()) {
          if (index < startIndex || index >= endIndex) {
            element.remove();
            this.pool.release(element);
            this.renderedItems.delete(index);
          }
        }

        // Add items in visible range
        for (let i = startIndex; i < endIndex; i++) {
          if (!this.renderedItems.has(i)) {
            const item = this.items[i];
            const element = this.pool.acquire();
            configure(item, element);

            // Position element
            const row = Math.floor(i / this.itemsPerRow);
            const col = i % this.itemsPerRow;
            element.className = 'item virtual-item';
            element.style.top = `${row * this.itemHeight + 16}px`;
            element.style.left = `${col * this.itemWidth + 16}px`;

            this.container.appendChild(element);
            this.renderedItems.set(i, element);
          }
        }
      }

      destroy() {
        this.scrollContainer.removeEventListener('scroll', this.onScroll);
        this.renderedItems.forEach(element => this.pool.release(element));
        this.renderedItems.clear();
        this.pool.clear();
      }
    }

    // ===== NO OPTIMIZATION APPROACH =====
    class NoOptimizationList {
      constructor(container, items) {
        this.container = container;
        this.items = items;
      }

      render() {
        this.container.className = 'list-content';
        this.container.innerHTML = '';

        // Render all items as full elements
        const fragment = document.createDocumentFragment();
        this.items.forEach((item) => {
          const temp = document.createElement('div');
          temp.innerHTML = itemTemplate;
          const element = temp.firstElementChild;
          configure(item, element);
          fragment.appendChild(element);
        });
        this.container.appendChild(fragment);
      }

      destroy() {
        // Nothing to clean up
      }
    }

    // ===== CONTENT VISIBILITY APPROACH =====
    // Same as Placeholder but with content-visibility on placeholders
    class ContentVisibilityList {
      constructor(container, items) {
        this.container = container;
        this.items = items;
        this.pool = new ElementPool(itemTemplate);
        this.placeholderToItem = new Map();
        this.itemToElement = new Map();
        this.observer = null;
      }

      render() {
        this.container.className = 'list-content';
        this.container.innerHTML = '';

        // Create all placeholders with content-visibility
        const fragment = document.createDocumentFragment();
        this.items.forEach((item, index) => {
          const temp = document.createElement('div');
          temp.innerHTML = placeholderTemplate;
          const placeholder = temp.firstElementChild;
          placeholder.dataset.index = index;
          placeholder.classList.add('content-visibility-item');
          this.placeholderToItem.set(placeholder, item);
          fragment.appendChild(placeholder);
        });
        this.container.appendChild(fragment);

        // Set up intersection observer
        this.observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const placeholder = entry.target;
            const item = this.placeholderToItem.get(placeholder);

            if (!item) return;

            if (entry.isIntersecting) {
              // Swap placeholder -> full element
              if (!this.itemToElement.has(item)) {
                const element = this.pool.acquire();
                configure(item, element);
                placeholder.replaceWith(element);
                this.placeholderToItem.delete(placeholder);
                this.placeholderToItem.set(element, item);
                this.itemToElement.set(item, element);
              }
            } else {
              // Swap full element -> placeholder
              const element = this.itemToElement.get(item);
              if (element) {
                const temp = document.createElement('div');
                temp.innerHTML = placeholderTemplate;
                const newPlaceholder = temp.firstElementChild;
                newPlaceholder.dataset.index = placeholder.dataset.index;
                newPlaceholder.classList.add('content-visibility-item');

                element.replaceWith(newPlaceholder);
                this.placeholderToItem.delete(element);
                this.placeholderToItem.set(newPlaceholder, item);
                this.itemToElement.delete(item);
                this.pool.release(element);
              }
            }
          });
        }, {
          root: this.container.parentElement,
          rootMargin: '200px'
        });

        // Observe all placeholders
        this.container.querySelectorAll('.placeholder').forEach(p => {
          this.observer.observe(p);
        });
      }

      destroy() {
        if (this.observer) {
          this.observer.disconnect();
        }
        this.pool.clear();
        this.placeholderPool.clear();
        this.placeholderToItem.clear();
        this.itemToElement.clear();
      }
    }

    // ===== SCROLL PERSISTENCE =====
    function saveScrollState() {
      const scrollContainer = document.getElementById('listContainer');
      const approach = document.getElementById('approach').value;
      const count = document.getElementById('itemCount').value;

      localStorage.setItem('listState', JSON.stringify({
        approach,
        count,
        scrollTop: scrollContainer.scrollTop
      }));
    }

    function loadScrollState() {
      const saved = localStorage.getItem('listState');
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          return null;
        }
      }
      return null;
    }

    // ===== MAIN CONTROLS =====
    let currentList = null;

    // Save settings when they change
    document.getElementById('approach').addEventListener('change', () => {
      saveScrollState();
    });

    document.getElementById('itemCount').addEventListener('input', () => {
      saveScrollState();
    });

    document.getElementById('renderBtn').addEventListener('click', () => {
      const approach = document.getElementById('approach').value;
      const count = parseInt(document.getElementById('itemCount').value);

      // Clean up previous list
      if (currentList) {
        currentList.destroy();
      }

      // Generate items
      items = generateItems(count);

      // Render with timing
      const startTime = performance.now();

      const container = document.getElementById('listContent');
      const scrollContainer = document.getElementById('listContainer');

      if (approach === 'placeholder') {
        currentList = new PlaceholderList(container, items);
        currentList.render();
      } else if (approach === 'virtual') {
        currentList = new VirtualList(container, items);
        currentList.render();
      } else if (approach === 'content-visibility') {
        currentList = new ContentVisibilityList(container, items);
        currentList.render();
      } else {
        currentList = new NoOptimizationList(container, items);
        currentList.render();
      }

      const endTime = performance.now();
      const renderTime = Math.round(endTime - startTime);
      document.getElementById('renderTime').textContent = `Render time: ${renderTime}ms`;

      // Save state on scroll
      scrollContainer.addEventListener('scroll', saveScrollState, { passive: true });
    });

    // Restore state on load
    const savedState = loadScrollState();
    if (savedState) {
      document.getElementById('approach').value = savedState.approach;
      document.getElementById('itemCount').value = savedState.count;

      // Render and restore scroll position
      document.getElementById('renderBtn').click();

      // Restore scroll after render settles
      requestAnimationFrame(() => {
        const scrollContainer = document.getElementById('listContainer');
        scrollContainer.scrollTop = savedState.scrollTop;
      });
    } else {
      // Initial render
      document.getElementById('renderBtn').click();
    }
  </script>
</body>
</html>